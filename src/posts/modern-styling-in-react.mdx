---
title: Современный подход к стилизации в React
abstract: Несколько хитрых техник для динамической стилизации компонентов React с использованием пользовательских свойств CSS
date: '2022-05-01'
banner: /static/modern-react-css-banner.jpg
featured: true
---

Когда я впервые попробовал библиотеки CSS-in-JS, такие как [Styled Components](https://styled-components.com/) и [Emotion](https://emotion.sh), то то, что касалось мне, это передача значений или состояния напрямую в стили компонента. Это действительно закрывало цикл с концепцией React, где интерфейс пользователя является функцией состояния. Хотя это было определенным продвижением по сравнению с традиционным способом стилизации React с использованием классов и предварительно обработанного CSS, у этого подхода тоже были свои проблемы.

Чтобы проиллюстрировать некоторые примеры, я рассмотрю некоторые типичные случаи, используя два основных типа динамических стилей, с которыми вы столкнетесь при работе с компонентами React:

1. **Значения:** такие как цвет, задержка или позиция. Все, что представляет собой одно значение для свойства CSS.
2. **Состояния:** например, вариант основной кнопки или состояние загрузки, каждое из которых имеет свой набор связанных стилей.

## Где мы находимся сегодня

Прежде чем мы начнем, для сравнения я буду использовать SCSS (с синтаксисом [BEM](https://css-tricks.com/bem-101/)) и Styled Components в моих примерах для демонстрации того, как обычно подходится к стилизации в React. Я не буду рассматривать библиотеки CSS-in-JS, которые работают с написанием CSS в виде объектов JavaScript. Я считаю, что уже есть хорошие решения (рекомендую [Vanilla Extract](https://vanilla-extract.style/)), если вы предпочитаете проверку типов и полностью ориентированы на сторону JavaScript. Мое решение больше для тех из нас, кто любит писать CSS как CSS, но хочет лучшим образом реагировать на реактивность и состояние компонентов.

Если вы уже знакомы с проблемой, [перейдите к решению](#theres-a-better-way-vanilla-css).

### Значения

Используя чистый CSS или предварительно обработанный CSS с помощью LESS или SCSS, традиционным способом передачи _значения_ в ваши стили было просто использование встроенных стилей. Так что, если у нас есть компонент кнопки, который позволяет выбрать цвет, это будет выглядеть примерно так:

```jsx
function Button({ color, children }) {
  return (
    <button className="button" style={{ backgroundColor: color }}>
      {children}
    </button>
  );
}
Проблема этого подхода заключается в том, что он приносит все проблемы встроенных стилей. Теперь у него более высокая специфичность, что делает его сложнее для переопределения, и стили не находятся в одном месте вместе с остальными стилями нашей кнопки.

CSS-in-JS (в случае Styled Components или Emotion) решает эту проблему, позволяя таким образом динамическим значениям быть переданными как свойства:
// Мы можем передать значение `color` в стилизованный компонент как свойство
function Button({ color, children }) {
  return <StyledButton color={color}>{children}</StyledButton>;
}

// Синтаксис немного странный, но теперь в стилях стилизованного компонента
// мы можем использовать его свойства как функцию
const StyledButton = styled.button`
  border: 0;
  border-radius: 4px;
  padding: 8px 12px;
  font-size: 14px;
  color: dimgrey;
  background-color: ${props => props.color};
`;
Состояния
Традиционно мы использовали классы CSS и конкатенировали строки. Это всегда казалось неряшливым и неуклюжим, но это отлично работает с точки зрения CSS, особенно если вы используете соглашение об именовании вроде BEM вместе с препроцессорами. Допустим, у нас есть размеры кнопок small, medium и large, и вариант основной кнопки, это может выглядеть примерно так:
function Button({ color, size, primary, children }) {
  return (
    <button
      className={['button', `button--${size}`, primary ? 'button--primary' : null]
        .filter(Boolean)
        .join(' ')}
      style={{ backgroundColor: color }}
    >
      {children}
    </button>
  );
}
.button {
  border: 0;
  border-radius: 4px;
  padding: 8px 12px;
  font-size: 14px;
  color: dimgrey;
  background-color: whitesmoke;

  &--primary {
    background-color: $primary-color;
  }

  &--small {
    height: 30px;
  }

  &--medium {
    height: 40px;
  }

  &--large {
    height: 60px;
  }
}
SCSS выглядит аккуратным. Мне всегда нравился шаблон использования вложенности для конкатенации элементов и модификаторов в SCSS с использованием синтаксиса BEM.

Однако наш JSX не справляется так хорошо. Эта конкатенация строк в className - это беспорядок. Свойство size не так уж плохо, потому что мы присоединяем значение непосредственно к классу. Но вариант с primary... фу. Не говоря уже о странном filter(Boolean) там, чтобы предотвратить двойной пробел в списке классов для не-основных кнопок. Есть более хорошие способы обработки этого, например, пакет classnames в NPM. Но они делают проблему чуть более приемлемой.

В отличие от динамических значений, Styled Components все еще немного громоздки при работе со состояниями:
function Button({ color, size, primary, children }) {
  return (
    <StyledButton color={color}>{children}</StyledButton>
  }
);


const StyledButton = styled.button`
  border: 0;
  border-radius: 4px;
  padding: 8px 12px;
  font-size: 14px;
  color: dimgrey;
  background-color: whitesmoke;

  ${props => props.primary && css`
    background-color: $primary-color;
  `}

  ${props => props.size === 'small' && css`
    height: 30px;
  `}

  ${props => props.size === 'medium' && css`
    height: 40px;
  `}

  ${props => props.size === 'large' && css`
    height: 60px;
  `}
`;
Это не ужасно, но повторяющиеся функции для извлечения свойств становятся монотонными и делают чтение стилей довольно шумным. Это также может ухудшиться в зависимости от типа состояния. Если у вас есть отдельные, но взаимоисключающие состояния, иногда требуется тернарное выражение, которое может оказаться еще более запутанным и сложным для восприятия.
const StyledButton = styled.button`
  border: 0;
  border-radius: 4px;
  padding: 8px 12px;
  font-size: 14px;
  color: dimgrey;

  ${props =>
    props.primary
      ? css`
          height: 60px;
          background-color: darkslateblue;
        `
      : css`
          height: 40px;
          background-color: whitesmoke;
        `}
`;
Если вы используете Prettier для форматирования кода, как и я, у вас получится нечто подобное, как вы видите выше. "Чудовище" - это сильное слово, но я считаю, что форматирование и формирование отступов действительно трудночитаемыми.
Есть лучший способ: ванильный CSS
Решение было с нами все время: пользовательские свойства CSS (или переменные CSS). Ну, не совсем так. Когда были установлены методы, о которых я рассказывал выше, пользовательские свойства CSS еще не так хорошо поддерживались браузерами. На сегодняшний день поддержка вполне приемлема (если вы все еще должны поддерживать ie11).

Пройдя путь от использования SCSS к Styled Components, я вернулся к ванильному CSS. Мне кажется, что наблюдается тенденция придерживаться стандартов платформы с фреймворками, такими как Remix и Deno, придерживающимися стандартов веба, вместо того чтобы делать свои собственные вещи. Я думаю, это произойдет и с CSS, мы не будем так часто прибегать к предварительным процессорам и библиотекам CSS-in-JS, потому что собственные возможности становятся лучше, чем то, что они предлагают.

Сказав это, вот как я подошел к стилизации компонентов React с использованием ванильного CSS. Ну, в основном ванильного CSS. Я использую postcss для поддержки некоторых новых функций, таких как собственное вложение и пользовательские медиа-запросы. Прелесть postcss в том, что по мере того, как браузеры поддерживают новые функции, инструменты постепенно уходят.

Значения
Очень интересный трюк для передачи значений в CSS - использование пользовательских свойств. Это довольно просто, мы можем просто вставить переменные в свойство стиля, и это работает.
function Button({ color, children }) {
  return (
    <button className="button" style={{ '--color': color }}>
      {children}
    </button>
  );
}
.button {
  border: 0;
  border-radius: 4px;
  padding: 8px 12px;
  font-size: 14px;
  color: dimgrey;
  background-color: var(--color);
}
Теперь вы можете подумать: "разве это просто встроенные стили с дополнительными шагами?", и хотя мы используем встроенные стили для применения переменной, это не сопровождается теми же недостатками. Прежде всего, нет проблемы с селективностью, потому что мы объявляем свойство под селектором .button в файле CSS. Во-вторых, все наши стили находятся в одном месте, передается только значение пользовательского свойства.

Это также делает его очень удобным при работе с такими свойствами, как transforms или clip-path, где вам нужно динамически управлять только одним куском значения.
// Все, что нам нужно передать, - это значение, необходимое для трансформации, вместо того
// чтобы загрязнять наш jsx полным трансформированием в стиле inline
function Button({ offset, children }) {
  return (
    <button className="button" style={{ '--offset': `${offset}px` }}>
      {children}
    </button>
  );
}
.button {
  border: 0;
  padding: 8px 12px;
  font-size: 14px;
  color: dimgrey;
  background-color: whitesmoke;
  transform: translate3d(0, var
С пользовательскими свойствами CSS можно делать гораздо больше, например, устанавливать значения по умолчанию и позволять переопределения из каскада для любых компонентов, составляющих друг друга, чтобы подключиться, как "CSS API".[В этой статье от Lea Verou](https://lea.verou.me/2021/10/custom-properties-with-defaults/) отлично объясняется эта техника.
Состояния
Лучший способ, который я нашел для работы со состоянием и вариантами компонентов с использованием ванильного CSS - использование данных атрибутов. Мне нравится то, что это хорошо сочетается с грядущим синтаксисом собственного вложения CSS. Старая техника выбора модификаторов BEM с &--modifier не работает так, как в препроцессорах. Но с атрибутами данных у нас есть похожие эргономичные возможности.
function Button({ color, size, primary, children }) {
  return (
    <button className="button" data-size={size} data-primary={primary}>
      {children}
    </button>
  );
}
.button {
  border: 0;
  border-radius: 4px;
  padding: 8px 12px;
  font-size: 14px;
  color: dimgrey;
  background-color: whitesmoke;

  &[data-primary='true'] {
    background-color: var(--colorPrimary);
  }

  &[data-size='small'] {
    height: 30px;
  }

  &[data-size='medium'] {
    height: 40px;
  }

  &[data-size='large'] {
    height: 60px;
  }
}
Поиграйте с примером компонента кнопки здесь:

<Embed src="https://stackblitz.com/edit/vitejs-vite-mjs1oh?embed=1&file=src/Button/Button.jsx" />
Это похоже на то, как модификаторы написаны с использованием синтаксиса BEM. Это также намного проще и легче воспринимается, чем синтаксис функции Styled Components. Единственным недостатком является то, что мы получаем уровень специфичности, который не получаем с модификаторами BEM, используя шаблон &--modifier, но я считаю, что это приемлемый компромисс.

Сначала может показаться каким-то странным использование атрибутов данных для стилизации, но это позволяет избежать проблемы запутанной конкатенации строк с использованием классов. Это также отражает то, как мы можем настраивать атрибуты доступности для стилизации, например:
.button {
  &[aria-pressed='true'] {
    background-color: gainsboro;
  }

  &[disabled] {
    opacity: 0.4;
  }
}
I like this approach because it helps structure styling, we can see that any class is styling the base element, andy any attribute is styling a state. As for avoiding style clashes, there are better options now that automate the process like [CSS Modules](https://github.com/css-modules/css-modules) which is included out of the box in most React frameworks like Next.js and Create React App.

Of course, these techniques don't require you to _only_ use vanilla CSS, you can just as easily combine them with CSS-in-JS or a pre-processor. However with new features like [nesting](https://www.w3.org/TR/css-nesting-1/) and [relative colors](https://www.w3.org/TR/css-color-5/#relative-colors) I think it's becoming less necessary to reach for these tools.

The entirety of this website is styled using these techniques, so if you want to see an example of how this applies to some real components, take a gander at the [source code](https://github.com/HamishMW/portfolio).

